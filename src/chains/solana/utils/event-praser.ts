/**
 * Solana Event Parsing Utilities
 * 
 * Parse events emitted by Solana programs from transaction logs.
 * Anchor events are encoded in the transaction logs as base64 strings.
 * 
 * ## Event Format
 * 
 * Anchor emits events with this log format:
 * ```
 * Program log: {event_discriminator}{event_data_base64}
 * ```
 * 
 * The discriminator is 8 bytes derived from the event name.
 */

import { BN } from '@coral-xyz/anchor';
import { PublicKey } from '@solana/web3.js';

/**
 * RoomEnded event structure (from quiz_core IDL)
 */
export interface RoomEndedEvent {
  room: PublicKey;
  winners: PublicKey[];
  platformAmount: BN;
  hostAmount: BN;
  charityAmount: BN;
  intentIdHash: number[];
  prizeAmount: BN;
  totalPlayers: number;
  timestamp: BN;
}

/**
 * Parse RoomEnded event from transaction logs
 * 
 * @param logs - Transaction logs from connection.getTransaction()
 * @param decimals - Token decimals for converting to decimal string
 * @returns Parsed event data or null if not found
 */
export function parseRoomEndedEvent(
  logs: string[],
  decimals: number = 6
): {
  event: RoomEndedEvent | null;
  charityAmountDecimal: string | null;
} {
  console.log('[EventParser] üîç Parsing RoomEnded event from logs...');

  if (!logs || logs.length === 0) {
    console.warn('[EventParser] ‚ö†Ô∏è No logs provided');
    return { event: null, charityAmountDecimal: null };
  }

  // RoomEnded event discriminator (first 8 bytes of sha256("event:RoomEnded"))
  // This is automatically generated by Anchor
  const ROOM_ENDED_DISCRIMINATOR = [204, 239, 146, 218, 190, 21, 193, 184];

  // Look for the event in logs
  // Anchor events are logged as "Program data: {base64_encoded_event}"
  for (const log of logs) {
    if (!log.includes('Program data:')) {
      continue;
    }

    try {
      // Extract base64 data after "Program data: "
      const base64Data = log.split('Program data: ')[1]?.trim();
      if (!base64Data) {
        continue;
      }

      // Decode base64 to buffer
      const buffer = Buffer.from(base64Data, 'base64');

      // Check if discriminator matches RoomEnded
      const discriminator = Array.from(buffer.slice(0, 8));
      const isRoomEndedEvent = discriminator.every(
        (byte, i) => byte === ROOM_ENDED_DISCRIMINATOR[i]
      );

      if (!isRoomEndedEvent) {
        continue;
      }

      console.log('[EventParser] ‚úÖ Found RoomEnded event!');

      // Parse event data (starts after 8-byte discriminator)
      let offset = 8;

      // Parse room (PublicKey - 32 bytes)
      const roomBytes = buffer.slice(offset, offset + 32);
      const room = new PublicKey(roomBytes);
      offset += 32;

      // Parse winners (Vec<Pubkey>)
      // First 4 bytes = length of vector
      const winnersLength = buffer.readUInt32LE(offset);
      offset += 4;

      const winners: PublicKey[] = [];
      for (let i = 0; i < winnersLength; i++) {
        const winnerBytes = buffer.slice(offset, offset + 32);
        winners.push(new PublicKey(winnerBytes));
        offset += 32;
      }

      // Parse platform_amount (u64 - 8 bytes)
      const platformAmountBytes = buffer.slice(offset, offset + 8);
      const platformAmount = new BN(platformAmountBytes, 'le');
      offset += 8;

      // Parse host_amount (u64 - 8 bytes)
      const hostAmountBytes = buffer.slice(offset, offset + 8);
      const hostAmount = new BN(hostAmountBytes, 'le');
      offset += 8;

      // Parse charity_amount (u64 - 8 bytes) ‚≠ê THIS IS WHAT WE NEED!
      const charityAmountBytes = buffer.slice(offset, offset + 8);
      const charityAmount = new BN(charityAmountBytes, 'le');
      offset += 8;

      // Parse intent_id_hash ([u8; 32] - 32 bytes)
      const intentIdHash = Array.from(buffer.slice(offset, offset + 32));
      offset += 32;

      // Parse prize_amount (u64 - 8 bytes)
      const prizeAmountBytes = buffer.slice(offset, offset + 8);
      const prizeAmount = new BN(prizeAmountBytes, 'le');
      offset += 8;

      // Parse total_players (u32 - 4 bytes)
      const totalPlayers = buffer.readUInt32LE(offset);
      offset += 4;

      // Parse timestamp (i64 - 8 bytes)
      const timestampBytes = buffer.slice(offset, offset + 8);
      const timestamp = new BN(timestampBytes, 'le');
      offset += 8;

      const event: RoomEndedEvent = {
        room,
        winners,
        platformAmount,
        hostAmount,
        charityAmount,
        intentIdHash,
        prizeAmount,
        totalPlayers,
        timestamp,
      };

      // Convert charity amount to decimal string
      const charityAmountDecimal = (
        Number(charityAmount.toString()) / Math.pow(10, decimals)
      ).toFixed(decimals);

      console.log('[EventParser] üìä RoomEnded event parsed:');
      console.log('[EventParser]   Room:', room.toBase58());
      console.log('[EventParser]   Winners:', winners.length);
      console.log('[EventParser]   Platform amount:', platformAmount.toString());
      console.log('[EventParser]   Host amount:', hostAmount.toString());
      console.log('[EventParser]   Charity amount:', charityAmount.toString());
      console.log('[EventParser]   Charity (decimal):', charityAmountDecimal);
      console.log('[EventParser]   Prize amount:', prizeAmount.toString());
      console.log('[EventParser]   Total players:', totalPlayers);

      return { event, charityAmountDecimal };
    } catch (error: any) {
      console.error('[EventParser] ‚ùå Error parsing log:', error.message);
      // Continue to next log
      continue;
    }
  }

  console.warn('[EventParser] ‚ö†Ô∏è RoomEnded event not found in logs');
  return { event: null, charityAmountDecimal: null };
}

/**
 * Fetch transaction and parse RoomEnded event
 * 
 * @param connection - Solana connection
 * @param signature - Transaction signature
 * @param decimals - Token decimals
 * @param maxRetries - Max retry attempts (transactions take time to confirm)
 * @returns Parsed event or null
 */
export async function fetchAndParseRoomEndedEvent(
  connection: any,
  signature: string,
  decimals: number = 6,
  maxRetries: number = 10
): Promise<{
  event: RoomEndedEvent | null;
  charityAmountDecimal: string | null;
}> {
  console.log('[EventParser] üîç Fetching transaction:', signature);

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      // Fetch transaction with maxSupportedTransactionVersion
      const tx = await connection.getTransaction(signature, {
        maxSupportedTransactionVersion: 0,
        commitment: 'confirmed',
      });

      if (!tx) {
        console.log(`[EventParser] ‚è≥ Transaction not found yet (attempt ${attempt + 1}/${maxRetries})`);
        
        // Wait before retry (exponential backoff)
        await new Promise((resolve) => setTimeout(resolve, Math.min(1000 * Math.pow(2, attempt), 5000)));
        continue;
      }

      if (!tx.meta) {
        console.warn('[EventParser] ‚ö†Ô∏è Transaction has no metadata');
        return { event: null, charityAmountDecimal: null };
      }

      // Get logs from transaction metadata
      const logs = tx.meta.logMessages || [];
      console.log('[EventParser] üìú Found', logs.length, 'log messages');

      // Parse the event
      return parseRoomEndedEvent(logs, decimals);
    } catch (error: any) {
      console.error('[EventParser] ‚ùå Error fetching transaction:', error.message);
      
      if (attempt === maxRetries - 1) {
        // Last attempt failed
        return { event: null, charityAmountDecimal: null };
      }

      // Wait before retry
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }
  }

  console.error('[EventParser] ‚ùå Failed to fetch transaction after', maxRetries, 'attempts');
  return { event: null, charityAmountDecimal: null };
}

/**
 * Parse WinnersDeclared event from transaction logs
 */
export interface WinnersDeclaredEvent {
  room: PublicKey;
  winners: PublicKey[];
  timestamp: BN;
}

export function parseWinnersDeclaredEvent(logs: string[]): WinnersDeclaredEvent | null {
  console.log('[EventParser] üîç Parsing WinnersDeclared event from logs...');

  if (!logs || logs.length === 0) {
    console.warn('[EventParser] ‚ö†Ô∏è No logs provided');
    return null;
  }

  // WinnersDeclared event discriminator
  const WINNERS_DECLARED_DISCRIMINATOR = [60, 25, 114, 88, 126, 49, 88, 136];

  for (const log of logs) {
    if (!log.includes('Program data:')) {
      continue;
    }

    try {
      const base64Data = log.split('Program data: ')[1]?.trim();
      if (!base64Data) continue;

      const buffer = Buffer.from(base64Data, 'base64');

      const discriminator = Array.from(buffer.slice(0, 8));
      const isWinnersDeclaredEvent = discriminator.every(
        (byte, i) => byte === WINNERS_DECLARED_DISCRIMINATOR[i]
      );

      if (!isWinnersDeclaredEvent) continue;

      console.log('[EventParser] ‚úÖ Found WinnersDeclared event!');

      let offset = 8;

      // Parse room (PublicKey)
      const roomBytes = buffer.slice(offset, offset + 32);
      const room = new PublicKey(roomBytes);
      offset += 32;

      // Parse winners (Vec<Pubkey>)
      const winnersLength = buffer.readUInt32LE(offset);
      offset += 4;

      const winners: PublicKey[] = [];
      for (let i = 0; i < winnersLength; i++) {
        const winnerBytes = buffer.slice(offset, offset + 32);
        winners.push(new PublicKey(winnerBytes));
        offset += 32;
      }

      // Parse timestamp (i64)
      const timestampBytes = buffer.slice(offset, offset + 8);
      const timestamp = new BN(timestampBytes, 'le');

      console.log('[EventParser] üìä WinnersDeclared event parsed:');
      console.log('[EventParser]   Room:', room.toBase58());
      console.log('[EventParser]   Winners:', winners.map(w => w.toBase58()));

      return { room, winners, timestamp };
    } catch (error: any) {
      console.error('[EventParser] ‚ùå Error parsing log:', error.message);
      continue;
    }
  }

  console.warn('[EventParser] ‚ö†Ô∏è WinnersDeclared event not found in logs');
  return null;
}